---
title: "Survey Weighting Exercise: Nonvoter Study Analysis"
date: "2025-04-01"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
library(tidyverse)
```

# Introduction

This notebook explores how survey weighting affects data analysis and interpretation in journalism. We'll use a dataset from a 2020 survey on voting behavior to understand weighting concepts and how they can change our understanding of public opinion data. The codebook with the questions from the survey is here: https://github.com/dwillis/jour405_files/blob/main/nonvoters_codebook.pdf

## What is Survey Weighting?

Survey weighting is like adjusting the volume on different voices in a conversation to make sure everyone is heard equally. In survey research:

- Some groups of people are more likely to answer surveys than others
- This can make the survey sample different from the actual population
- Survey weights help fix this imbalance by giving more "volume" to underrepresented groups and less to overrepresented groups

**For example:** If your survey has too many college graduates compared to the general population, you might give each college graduate's response a weight of 0.8 (counting as 80% of a response) and each non-college graduate a weight of 1.2 (counting as 120% of a response).

## Why Should Journalists Care?

- Unweighted results might give a misleading picture of public opinion
- Proper weighting helps ensure your reporting accurately represents the community
- Understanding weighting helps you critically evaluate polls from other sources
- Small differences in weighting can sometimes change the headline of your story

## Our Questions

1. How does weighting affect our estimates of voting intentions?
2. Which demographic groups show the largest differences between weighted and unweighted results?
3. How might weighting influence reporting of this data?

# Data Overview

The nonvoters dataset contains survey responses about voting intentions and behaviors from 5,836 American adults. The survey was conducted prior to the 2020 election and includes a variety of demographic information and political attitudes.

```{r load-data}
# Load the dataset
nonvoters_data <- read_csv("https://raw.githubusercontent.com/dwillis/jour405_files/refs/heads/main/nonvoters_data.csv")

# Look at the structure of the data
glimpse(nonvoters_data)
```

Let's break down the key variables we'll focus on:

- `weight`: The survey weight assigned to each respondent, showing how much their response "counts"
- `Q21`: Voting intention with these values:
  - 1 = Yes (plans to vote)
  - 2 = No (does not plan to vote)
  - 3 = Unsure/Undecided
- `voter_category`: Respondent's voting history:
  - "always": Votes in all or nearly all elections
  - "sporadic": Votes occasionally
  - "rarely/never": Rarely or never votes
- Demographics: `race`, `gender`, `educ` (education level), `income_cat`

# Understanding Survey Weights

Before we dive into the analysis, let's examine the weights in our dataset to understand how they're distributed.

```{r examine-weights}
# Summary statistics of weights
summary(nonvoters_data$weight)

# Histogram of weights
ggplot(nonvoters_data, aes(x = weight)) +
  geom_histogram(bins = 30, fill = "skyblue", color = "white") +
  theme_minimal() +
  labs(
    title = "Distribution of Survey Weights",
    x = "Weight",
    y = "Count"
  )
```

**Explanation:** 
- The summary statistics show us the minimum, maximum, and typical weights in the dataset
- The histogram shows how many respondents have each weight value
- Most weights cluster around 1.0 (which means those respondents count as exactly one person)
- Weights below 1.0 mean a respondent is overrepresented (counts as less than one person)
- Weights above 1.0 mean a respondent is underrepresented (counts as more than one person)

**Discussion Questions:**
1. What is the range of weights in this dataset?
2. What does it mean when a respondent has a weight of 0.23? What about 3.04?
3. Why might some respondents be weighted more heavily than others?

# Exercise 1: Voter Categories and Weighting

First, let's look at how many people fall into each voting category in our sample.

```{r voter-categories}
# Count of respondents by voter category
nonvoters_data |>
  count(voter_category) |>
  mutate(percentage = n / sum(n) * 100) |>
  kable(digits = 1, col.names = c("Voter Category", "Count", "Percentage (%)"))
```

**Explanation:** This table shows the breakdown of our sample by voting history. We can see that most respondents (44.1%) are "sporadic" voters, followed by "always" voters (31.0%), and "rarely/never" voters (24.9%).

Now, let's compare unweighted and weighted voting intentions by voter category.

## Part A: Unweighted Analysis

First, we'll calculate the raw percentages without applying weights:

```{r unweighted-by-category}
# Calculate unweighted percentages
unweighted_by_voter_category <- nonvoters_data |>
  # Filter out missing responses
  filter(!is.na(Q21), Q21 > 0) |>
  # Group by voter category and response
  group_by(voter_category, Q21) |>
  # Count responses in each group
  summarize(count = n(), .groups = "drop_last") |>
  # Calculate percentages within each voter category
  mutate(total = sum(count),
         percentage = count / total * 100) |>
  ungroup()

# Create a more readable version with voting intentions as columns
unweighted_summary <- unweighted_by_voter_category |>
  pivot_wider(
    id_cols = voter_category,
    names_from = Q21,
    values_from = percentage,
    names_prefix = "pct_"
  ) |>
  rename(
    "Yes (%)" = pct_1,
    "No (%)" = pct_2,
    "Unsure (%)" = pct_3
  )

kable(unweighted_summary, digits = 1, caption = "Unweighted Voting Intentions by Voter Category")
```

**Explanation:**
- This table shows the percentage of respondents in each voter category who said "Yes," "No," or "Unsure" when asked if they plan to vote
- We calculated these percentages by simply counting responses and dividing by the total in each category
- No weights have been applied yetâ€”each respondent counts equally
- Notice that even among "rarely/never" voters, a high percentage (71.8%) say they plan to vote in the upcoming election

## Part B: Weighted Analysis

Now, let's apply the survey weights to the same analysis. Instead of just counting respondents, we'll sum their weights:

```{r weighted-by-category}
# YOUR TASK: Calculate the weighted percentages
# Use the weight variable to adjust the counts

weighted_by_voter_category <- nonvoters_data |>
  # Filter out missing responses, same as before
  filter(!is.na(Q21), Q21 > 0) |>
  # Group by voter category and response
  group_by(voter_category, Q21) |>
  # Instead of counting, sum the weights
  summarize(weighted_count = sum(weight), .groups = "drop_last") |>
  # Calculate percentages based on weighted counts
  mutate(weighted_total = sum(weighted_count),
         weighted_percentage = weighted_count / weighted_total * 100) |>
  ungroup()

weighted_summary <- weighted_by_voter_category |>
  pivot_wider(
    id_cols = voter_category,
    names_from = Q21,
    values_from = weighted_percentage,
    names_prefix = "pct_"
  ) |>
  rename(
    "Yes (%)" = pct_1,
    "No (%)" = pct_2,
    "Unsure (%)" = pct_3
  )

kable(weighted_summary, digits = 1, caption = "Weighted Voting Intentions by Voter Category")
```

**Explanation:**
- Now we've calculated percentages by summing the weights instead of simply counting people
- Each respondent contributes to the total based on their assigned weight value
- This gives us estimates that should better reflect the true population
- Notice how some percentages have changed from the unweighted analysis

## Part C: Comparing Differences

Let's create a comparison table to clearly see the differences between weighted and unweighted results:

```{r category-comparison}
comparison <- unweighted_summary |>
  # Join the two tables to compare them
  inner_join(weighted_summary, by = "voter_category", suffix = c("_unweighted", "_weighted")) |>
  # Calculate the differences in percentage points
  mutate(
    yes_diff = `Yes (%)_weighted` - `Yes (%)_unweighted`,
    no_diff = `No (%)_weighted` - `No (%)_unweighted`,
    unsure_diff = `Unsure (%)_weighted` - `Unsure (%)_unweighted`
  ) |>
  # Select just the differences for our table
  select(voter_category, yes_diff, no_diff, unsure_diff) |>
  rename(
    "Yes (% point diff)" = yes_diff,
    "No (% point diff)" = no_diff,
    "Unsure (% point diff)" = unsure_diff
  )

kable(comparison, digits = 1, caption = "Difference Between Weighted and Unweighted Results (percentage points)")
```

**Explanation:**
- This table shows how many percentage points the results changed after applying weights
- Positive numbers mean the weighted percentage is higher; negative numbers mean it's lower
- For example, after weighting, the percentage of "rarely/never" voters saying "Yes" decreased by 3.7 percentage points
- These differences might seem small, but in a close election, even small shifts can be meaningful for reporting

**Analysis Questions:**
1. Which voter category shows the biggest difference between weighted and unweighted results?
2. How might these differences affect reporting on likely voter turnout?
3. Why do you think these differences exist? What does this tell us about who might be over or under-represented in the sample?

# Exercise 3: Race/Ethnicity and Weighting

Now let's examine how race/ethnicity interacts with survey weighting. First, let's look at the distribution of racial groups in our sample:

```{r race-distribution}
# Distribution of racial groups in sample
nonvoters_data |>
  count(race) |>
  mutate(percentage = n / sum(n) * 100) |>
  kable(digits = 1, col.names = c("Race/Ethnicity", "Count", "Percentage (%)"))
```

**Explanation:**
- This table shows us what percentage of our sample belongs to each racial/ethnic group
- White respondents make up the majority (63.6%), followed by Black (16.0%), Hispanic (13.9%), and Other/Mixed (6.5%)
- This distribution might not match the actual population, which is why weighting is important

## YOUR TASK: Analyze Racial Differences

Complete the following steps:

1. Calculate unweighted voting intentions by race
2. Calculate weighted voting intentions by race
3. Compare the differences and create a visualization
4. Interpret what these differences might mean for reporting

```{r race-analysis}
# YOUR CODE HERE
# Calculate unweighted results by race
unweighted_by_race <- nonvoters_data |>
  # Filter out missing values
  filter(!is.na(Q21), Q21 > 0, !is.na(race)) |>
  # Group by race and response
  group_by(race, Q21) |>
  # Count responses
  summarize(count = n(), .groups = "drop_last") |>
  # Calculate percentages
  mutate(total = sum(count),
         percentage = count / total * 100) |>
  ungroup()

# Format for display
unweighted_race_summary <- unweighted_by_race |>
  pivot_wider(
    id_cols = race,
    names_from = Q21,
    values_from = percentage,
    names_prefix = "pct_"
  ) |>
  rename(
    "Yes (%)" = pct_1,
    "No (%)" = pct_2,
    "Unsure (%)" = pct_3
  )

kable(unweighted_race_summary, digits = 1, caption = "Unweighted Voting Intentions by Race/Ethnicity")

# Calculate weighted results by race
weighted_by_race <- nonvoters_data |>
  # Filter out missing values
  filter(!is.na(Q21), Q21 > 0, !is.na(race)) |>
  # Group by race and response
  group_by(race, Q21) |>
  # Sum the weights
  summarize(weighted_count = sum(weight), .groups = "drop_last") |>
  # Calculate weighted percentages
  mutate(weighted_total = sum(weighted_count),
         weighted_percentage = weighted_count / weighted_total * 100) |>
  ungroup()

# Format for display
weighted_race_summary <- weighted_by_race |>
  pivot_wider(
    id_cols = race,
    names_from = Q21,
    values_from = weighted_percentage,
    names_prefix = "pct_"
  ) |>
  rename(
    "Yes (%)" = pct_1,
    "No (%)" = pct_2,
    "Unsure (%)" = pct_3
  )

kable(weighted_race_summary, digits = 1, caption = "Weighted Voting Intentions by Race/Ethnicity")

# Create comparison visualization
race_viz_data <- bind_rows(
  # Unweighted data for "Yes" responses
  unweighted_by_race |> 
    filter(Q21 == 1) |>
    mutate(Type = "Unweighted") |>
    select(Type, race, percentage),
  # Weighted data for "Yes" responses
  weighted_by_race |> 
    filter(Q21 == 1) |>
    mutate(
      Type = "Weighted",
      percentage = weighted_percentage
    ) |>
    select(Type, race, percentage)
)

# Visualization
ggplot(race_viz_data, aes(x = race, y = percentage, fill = Type)) +
  geom_bar(stat = "identity", position = "dodge") +
  geom_text(aes(label = sprintf("%.1f%%", percentage)), 
            position = position_dodge(width = 0.9), vjust = -0.5) +
  labs(
    title = "Weighted vs. Unweighted 'Yes' Responses by Race/Ethnicity",
    subtitle = "Q21: Do you plan to vote in the November 2020 election?",
    y = "Percentage (%)",
    x = "Race/Ethnicity"
  ) +
  scale_fill_manual(values = c("Unweighted" = "#619CFF", "Weighted" = "#F8766D")) +
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold"),
    legend.position = "bottom"
  )
```

**Explanation of the code:**
- First, we calculate the unweighted percentages for each racial group and voting response
- Then, we do the same calculation but apply survey weights
- We create a table for each set of results to compare them
- Finally, we create a visualization focusing on "Yes" responses to see the impact of weighting

**YOUR ANALYSIS:**
[Write your interpretation of the racial differences here. Consider questions like:
- Which racial/ethnic groups show the biggest changes after weighting?
- What might this tell us about who is over- or under-represented in the sample?
- How might these differences affect reporting on voting intentions by race?
- Would these changes affect a headline about racial differences in voting plans?]

# Exercise 4: Overall Impact of Weighting

Finally, let's look at how weighting affects the overall voting intention estimates for the entire sample:

```{r overall-impact}
# Calculate overall unweighted percentages
unweighted_overall <- nonvoters_data |>
  filter(!is.na(Q21), Q21 > 0) |>
  count(Q21) |>
  mutate(percentage = n / sum(n) * 100)

# Calculate overall weighted percentages
weighted_overall <- nonvoters_data |>
  filter(!is.na(Q21), Q21 > 0) |>
  group_by(Q21) |>
  summarize(weighted_count = sum(weight)) |>
  mutate(percentage = weighted_count / sum(weighted_count) * 100)

# Create comparison table
overall_comparison <- data.frame(
  Response = c("Yes", "No", "Unsure"),
  Unweighted = unweighted_overall$percentage,
  Weighted = weighted_overall$percentage,
  Difference = weighted_overall$percentage - unweighted_overall$percentage
)

kable(overall_comparison, digits = 1, caption = "Overall Voting Intentions: Unweighted vs. Weighted")

# Create visualization
viz_data <- bind_rows(
  data.frame(
    Type = "Unweighted",
    Response = c("Yes", "No", "Unsure"),
    Percentage = unweighted_overall$percentage
  ),
  data.frame(
    Type = "Weighted",
    Response = c("Yes", "No", "Unsure"),
    Percentage = weighted_overall$percentage
  )
) |>
  mutate(Response = factor(Response, levels = c("Yes", "No", "Unsure")))

ggplot(viz_data, aes(x = Response, y = Percentage, fill = Type)) +
  geom_bar(stat = "identity", position = "dodge") +
  geom_text(aes(label = sprintf("%.1f%%", Percentage)), 
            position = position_dodge(width = 0.9), vjust = -0.5) +
  labs(
    title = "Comparison of Weighted vs. Unweighted Voting Intentions",
    subtitle = "Q21: Do you plan to vote in the November 2020 election?",
    y = "Percentage (%)",
    x = "Response"
  ) +
  scale_fill_manual(values = c("Unweighted" = "#619CFF", "Weighted" = "#F8766D")) +
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold"),
    legend.position = "bottom"
  )
```

**Explanation:**
- This analysis shows the bottom-line impact of weighting on our overall results
- Without weights, 85.1% of respondents said they plan to vote
- After applying weights, this estimate drops to 82.6%
- That's a decrease of 2.5 percentage points
- The "No" and "Unsure" categories both increased with weighting
- For a journalist, this is meaningful: weighting suggests slightly lower voter turnout than the raw data indicates
- In a close election, a 2-3 percentage point difference could be very important to report accurately

# Exercise 5: Understanding Why Weighting Matters

Let's examine the demographic makeup of the sample before and after weighting to understand why the results changed:

```{r demographic-distributions}
# Voter category distribution - unweighted vs weighted
voter_cat_unweighted <- nonvoters_data |>
  count(voter_category) |>
  mutate(percentage = n / sum(n) * 100)

voter_cat_weighted <- nonvoters_data |>
  group_by(voter_category) |>
  summarize(weighted_count = sum(weight)) |>
  mutate(percentage = weighted_count / sum(weighted_count) * 100)

voter_cat_comparison <- data.frame(
  Category = voter_cat_unweighted$voter_category,
  Unweighted = voter_cat_unweighted$percentage,
  Weighted = voter_cat_weighted$percentage,
  Difference = voter_cat_weighted$percentage - voter_cat_unweighted$percentage
)

kable(voter_cat_comparison, digits = 1, caption = "Voter Category Distribution: Unweighted vs. Weighted")

# Visualization of voter category differences
voter_cat_viz <- bind_rows(
  voter_cat_unweighted |> 
    mutate(Type = "Unweighted") |>
    select(Type, voter_category, percentage),
  voter_cat_weighted |> 
    mutate(Type = "Weighted") |>
    select(Type, voter_category, percentage)
)

ggplot(voter_cat_viz, aes(x = voter_category, y = percentage, fill = Type)) +
  geom_bar(stat = "identity", position = "dodge") +
  geom_text(aes(label = sprintf("%.1f%%", percentage)), 
            position = position_dodge(width = 0.9), vjust = -0.5) +
  labs(
    title = "Distribution of Voter Categories: Weighted vs. Unweighted",
    y = "Percentage (%)",
    x = "Voter Category"
  ) +
  scale_fill_manual(values = c("Unweighted" = "#619CFF", "Weighted" = "#F8766D")) +
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold"),
    legend.position = "bottom"
  )
```

**Explanation:**
- This analysis helps us understand why the overall results changed after weighting
- The weighted sample has more "rarely/never" voters (+3.1 percentage points) and fewer "always" voters (-2.0 percentage points)
- Since "rarely/never" voters are less likely to say they'll vote, increasing their representation in the sample lowers the overall voting intention
- This suggests our sample had too many regular voters compared to the actual population
- This makes sense intuitively: people who vote regularly might be more likely to participate in surveys about voting
- Proper weighting helps correct this bias and gives us a more accurate estimate

# Final Analysis & Discussion

Based on your work in this notebook, write a brief analysis (approximately 250-300 words) addressing the following questions:

1. How does weighting affect the overall results? What is the main "story" that emerges from the weighted data compared to the unweighted data?

2. Which demographic groups showed the largest differences between weighted and unweighted results? Why do you think these groups were affected more by weighting?

3. From a journalistic perspective, how would reporting based on the weighted data differ from reporting based on the unweighted data? What additional context would you want to provide about the methodology?

4. If you were writing a news story about voting intentions based on this data, what would your headline be? How would you explain the survey methodology to readers?

```
[YOUR ANALYSIS HERE]
```

# Homework Assignment

Choose one of the following demographic variables: gender, income_cat, or ppage (age).

1. Calculate unweighted and weighted voting intentions for this variable
2. Create appropriate visualizations showing the differences
3. Write a brief journalistic summary (2-3 paragraphs) explaining what the weighting reveals about potential sampling biases and how it impacts the interpretation of voting intentions
4. Include at least one compelling visualization that effectively communicates your findings

Include your code, visualizations, and written analysis in a new R Markdown document.

**Hint:** For age (ppage), you might want to create age groups first. For example:
```r
# Creating age groups (you can adjust these ranges)
nonvoters_data <- nonvoters_data |>
  mutate(age_group = case_when(
    ppage < 30 ~ "18-29",
    ppage < 45 ~ "30-44",
    ppage < 60 ~ "45-59",
    TRUE ~ "60+"
  ))
```

Then analyze by these age groups rather than individual ages.
